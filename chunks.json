[
    {
        "chunk_id": "chunk_1",
        "text": "Hey there. How's it going everybody? In this video, we're going to be learning how to alter existing rows and columns in our data frames. So in the last video, we learned how to filter out specific information, and we can use those techniques here to also modify our data. So we'll learn how to update the data for our rows and our columns, and then in the next video, we will also learn how to add and remove rows and columns from our data frames. Now, I would like to mention that we do have a sponsor for this series of videos, and that is brilliant.org. So I really wanna thank Brilliant for sponsoring this series, and it would be great if you all could check them out using the link in the description section below and support the sponsors. And I'll talk more about their services in just a bit. So with that said, let's go ahead and get started. Okay. So let's look at how to update data within our rows and columns. The last couple of videos, we have already seen how we can filter specific data, but now let's take a look at those same concepts and use them to make changes to our data. So let's look at updating columns first, and then we'll update some rows. So I currently have my snippets file open here that we've seen in previous videos so that we can see what this looks like on a smaller dataset before seeing how to do this on our larger dataset, with that Stack Overflow survey data. Now before we modify the columns, let's take a look at these first using the columns attribute that we have seen in previous videos. So let me add a new cell here down",
        "start_time": 0.0,
        "end_time": 80.115005
    },
    {
        "chunk_id": "chunk_2",
        "text": "dataset before seeing how to do this on our larger dataset, with that Stack Overflow survey data. Now before we modify the columns, let's take a look at these first using the columns attribute that we have seen in previous videos. So let me add a new cell here down at the bottom. We can look at the columns just by saying df dot columns and we can see that we just have 3 columns here. So our column names are first, last, and email. So let's say that we wanted to update the columns to be a little more specific. So let's say that I wanted this to be First Name instead of First. So there's a couple of ways that we can do this. So first, if we want to rename all of the columns, then we can simply do an assignment using the columns attribute that I just used. So in order to do this, I could just use an assignment here and just pass in a list. So I could just pass in a list of all the different columns that I want these to be. So I'll call this, First Name, Last Name, and I'll just keep Email the same. So if I run this, let's now look at these columns again. And now we can see that those column names have changed. And if I actually look at the data frame here, then they show up, changed in the data frame as well. Now, I almost never use this because, this is used for when you're passing in different names for all of your columns. I usually only need to change the names of a few different columns. Now one thing that is a lot more common is the need to change something, specific",
        "start_time": 79.875,
        "end_time": 150.275
    },
    {
        "chunk_id": "chunk_3",
        "text": "I almost never use this because, this is used for when you're passing in different names for all of your columns. I usually only need to change the names of a few different columns. Now one thing that is a lot more common is the need to change something, specific about each column in our data frame. So for example, maybe, your columns are all uppercase and, you want them to be lowercase or vice versa. Or maybe your column names have spaces, and you want to replace the spaces in the column names with an underscore. In this case, we can use a list comprehension. So for example, let's say that I wanted to upper case all of the column names here. So in order to do this, I could use a list comprehension, and I could just say df columns is equal to, and now we'll just say, like, x dot upper 4xndf.columns. So if I print out that data frame after making that change, then we can see that now all of our column names, have been translated to uppercase. Now, another thing that you might wanna do is remove spaces and replace them with underscores, especially if you like using the dot notation to access a column name. That doesn't work if there are, you know, spaces in the column name because that's, just not correct syntax. So if you wanted to replace spaces with, underscores instead, then what you could do is just do something similar here and say df columns is equal to df dot columns dot str, we're using the str method on this columns series here, and then we can use the replace method, from that stream class. So I can just, pass in a space and say that we wanna replace",
        "start_time": 149.775,
        "end_time": 247.825
    },
    {
        "chunk_id": "chunk_4",
        "text": "similar here and say df columns is equal to df dot columns dot str, we're using the str method on this columns series here, and then we can use the replace method, from that stream class. So I can just, pass in a space and say that we wanna replace all those spaces with underscores. Now, this isn't gonna make any changes in our specific data frame because all of ours already have underscores. If I reverse this and I did an underscore and then a space, then we can see that now, we replaced all those underscores with spaces. That's probably not what you want though. I would rather have underscores instead of spaces. So if we do it this way, then that's how you replace all of those. But let me go ahead and set these columns back to the way that they were, before. I like lowercase, so I'm gonna change those back to lowercase there. And now, everything that we've seen so far applies to every one of our columns. But what if we only wanted to change some columns? Well, in this case, we can use the rename method and just pass in a dictionary of the columns that we want to change. So if I want to set the first name and last name back to what they were before, then I could say df. Rename. And now we can just pass in the columns, and we're going to pass in a dictionary of what we want here. So the key is going to be the old value, so I'll set first name back to first. So the value is going to be the new value for that column name. So we're going to map first name to first, and then I will map",
        "start_time": 247.325,
        "end_time": 329.21
    },
    {
        "chunk_id": "chunk_5",
        "text": "what we want here. So the key is going to be the old value, so I'll set first name back to first. So the value is going to be the new value for that column name. So we're going to map first name to first, and then I will map last name here to last. So I just have to put that in as a value there. And now if I run this now, then it might look like it worked. But if I look at my data frame, then those changes actually didn't go through. This is another one of those methods where if we actually, want that place to or if we want that change to take place, then we have to say in place is equal to true, because it'll just let us kinda see what it would look like if it worked, but it's not actually gonna change it. So saying in place equals to true, will make that change go through. So now if I rerun this again, then we can see that those column names are set back to the way that they were. Okay. So that's a quick look at updating our columns. Now, let's take a look at updating the data in our rows, and we'll spend the majority of video learning how to update data in our rows since there is so much more that we can do here. So first, let's look at how to update a single value. Now in the previous video, we saw how we can lookup values using loc and iloc and we'll use that as our starting point for setting values as well. So let's grab the row for John Doe, right here. It's row number 2. Let's grab that row and change his last",
        "start_time": 328.71,
        "end_time": 402.435
    },
    {
        "chunk_id": "chunk_6",
        "text": "in the previous video, we saw how we can lookup values using loc and iloc and we'll use that as our starting point for setting values as well. So let's grab the row for John Doe, right here. It's row number 2. Let's grab that row and change his last name to Smith. So in order to grab that row, we can simply grab that row with the index labeled 2. So we can say df dot loc of 2. If I run that, then we can see that we get that row of first name, John, last name, Doe. And if you wanted to use a conditional, like we saw in the last video to grab that row, then that's definitely possible too. You can do that as well. Now we could have said, you know, give me rows where the first name is equal to John and the last name is equal to Doe if we wanted to do that as a conditional. So now in order to update this information, there are a couple of ways that we can do this. We can just pass in all of the new values for this row by passing in a list. So I could just say that this row I want to set this equal to, and then pass in all the new values. So I'll say that I want to keep John the same, I want his last name to be equal to Smith, and then let's also change his email as well, so johnsmith@email.com. So if I run this and then we look at our data frame, then we can see that now that last row has a new last name and a new email address. Now what if we had a lot of columns, but we",
        "start_time": 402.195,
        "end_time": 474.155
    },
    {
        "chunk_id": "chunk_7",
        "text": "change his email as well, so johnsmith@email.com. So if I run this and then we look at our data frame, then we can see that now that last row has a new last name and a new email address. Now what if we had a lot of columns, but we only wanted to change a couple of values? So imagine, you know, with our survey data, we have, 85 different columns. So it would be a pain if we wanted to change a single row and we had to pass in or a single column, and we had to pass in this huge list of 85 different values. You know, that would really suck to need to pass in that entire list just to change those couple of values. So in this case, we can just specify the exact columns using loc. And again, we saw this before when learning how to use the, loc to filter data. So if I wanted to just change the last name and email, then first, let's just grab those specific values. So I can say df.loc, and then I can pass in a 2 for the rows. Then if you remember that we can also pass in a list as the second value here for the columns that we want. So I'll say that I want the last and I want the email. So if I run this, then we can see that we just get the last name and we just get the email. And now we can change this as well, using the same method that we used here above, but we don't need to pass in this, the values that are staying the same. So I don't need to pass in that John value anymore since we're not changing that.",
        "start_time": 473.99503,
        "end_time": 547.15
    },
    {
        "chunk_id": "chunk_8",
        "text": "the email. And now we can change this as well, using the same method that we used here above, but we don't need to pass in this, the values that are staying the same. So I don't need to pass in that John value anymore since we're not changing that. So let's change this back to dough just to make sure that this worked. So johndoe@email.com. So now if I run this, that should have made the assignment. And now if I look at our data frame, then we can see that those were set back. So now we have johndoejohndoe@email.com. Okay. And finally here, now let's just look at how to change a single value. You might be able to guess how it'd be done, but what we can do is just pass in a single row and a single column and just change that value. We don't need to pass in a list. So just to change that one value, I will copy this line here, but now I don't want a list of these columns. Let's just change the last name. So this won't be a list anymore. Now I'm just saying that I want row 2, the column of last, and we'll just set that equal to Smith. Whoops. Let me put that in the, string there. So if I run that, then we look at our data frame, then we can see that it only changed that one value. Now pandas does have another indexer called at, and this is specifically meant for changing or looking up a single value. Now honestly, I just use dot loc, from these most of the time, but the option is there if you want it. I'm assuming it's there for performance reasons. So if I wanted to change",
        "start_time": 546.72504,
        "end_time": 628.29504
    },
    {
        "chunk_id": "chunk_9",
        "text": "called at, and this is specifically meant for changing or looking up a single value. Now honestly, I just use dot loc, from these most of the time, but the option is there if you want it. I'm assuming it's there for performance reasons. So if I wanted to change this, back since this is just a single value, then instead of using dot loc, then I could all you also use dot at. So I'll do this exact same assignment here, and I'll change this back to dough. But instead of dot loc, I'm gonna say dot at, and let's just set that back. And then if I look at the data frame, then we can see that that worked as well. And I'll be honest here. I'll have to look at the documentation. I'm not really sure, why we would use dot at instead of dot loc when we only need to get or set a single value. Maybe it's, for performance reasons, but I personally find myself using loc and iloc even for single values. I actually did look it up in the Pandas documentation, but all it says there is that, it's there and that it's similar to dot loc. It doesn't provide any actual justification as to why we'd use it, but I wanted you to know that it's available since it's obviously there for a reason and hasn't been deprecated yet. Okay. So now, let me show you one mistake, that is very common, and that is when people try to change a value without using one of these indexers, without using .loc or .at. So, let me show you what this error or this warning would look like. So let's say that we have a large data frame where we want to find",
        "start_time": 628.055,
        "end_time": 704.39
    },
    {
        "chunk_id": "chunk_10",
        "text": "and that is when people try to change a value without using one of these indexers, without using .loc or .at. So, let me show you what this error or this warning would look like. So let's say that we have a large data frame where we want to find this John Doe person and change their last name to Smith. So one way that we could do this is to use a filter to grab that specific row. So I will come down here to the bottom, and I'll just create a filter here, and I will say that the email column of the data frame equals equals, John Doe at email.com. That is the filter that we're looking for. So if I apply this filter to my data frame, just you passing it in directly to the brackets like this, then we saw in the last video oops. And this is filt, not filter since filter is a built in, Python keyword. So if I pass in that filth variable there directly into the brackets, again, we saw this in the last video, If I run this, then we can see that that works for looking up these values. So that actually returned a data frame there that just has a single row. So we could grab that last name column just by accessing, that last name from that dataframe that was returned. So if I run this, then that works as well. We can see that we got that doe value. And finally, you might think that in order to change this last name to Smith, that we could just come up here and say, okay, we got that value. Now I want to set that equal to Smith. So if I run this, then you can",
        "start_time": 704.07,
        "end_time": 790.22
    },
    {
        "chunk_id": "chunk_11",
        "text": "got that doe value. And finally, you might think that in order to change this last name to Smith, that we could just come up here and say, okay, we got that value. Now I want to set that equal to Smith. So if I run this, then you can see that this big warning pops up here. And if we look at this warning, it says that we get this setting with copy warning. Okay. So we got a warning, but did it actually make that change to our data frame? So let's look at our data frame here. Okay. So we tried to change that last name to Smith. I've know we've I've know we've been going back and forth between these last names here, but it was Doe, and then we tried to change it to Smith, and that did not work. So it didn't make that change when we did the assignment this way. Now the reason that it didn't work here is a little complicated. Essentially, it's because the way that we're doing it here requires multiple operations in the background which can determine whether Pandas returns a view or a copy of our DataFrame. So when our value isn't getting set, it's because it's getting set on a temporary object that's just getting tossed out immediately after. So Pandas does a lot better job of explaining this, specific warning, and they have a little link here down to the documentation, directly within the warning itself. So if you want to learn more about this, then you can just click on that warning or go to this link, and it explains it in a lot more detail. But the moral of the story here is that when you're setting values, just use dot loc or",
        "start_time": 789.98,
        "end_time": 865.79004
    },
    {
        "chunk_id": "chunk_12",
        "text": "itself. So if you want to learn more about this, then you can just click on that warning or go to this link, and it explains it in a lot more detail. But the moral of the story here is that when you're setting values, just use dot loc or the dot at indexers that we've already seen, and you shouldn't have any problems. So we could rerun this same operation up here, at the top. And actually, let me just copy this, so that if anybody, I will put this notebook out here on after I'm done with this. And if people wanna see this exact error, then I will leave that cell there. So we could rerun this exact same operation, but instead of using these brackets directly here, I can just say d f dot loc, and then I want to apply those filters to my rows, and then I wanna grab the, last name column, as well. So if I run it this way instead and then we look at our data frame, then we can see that that change did go through. So we were able to apply that filter and then set that last name equal to Smith in that data frame. So if you ever get these warnings like this that just pop up, then definitely don't ignore them because, you know, in this case, it didn't even set the value that we thought that we were setting, so you really need to be careful with stuff like that. Okay. So that's how we would update a single row of data, but how would we update multiple rows of data? Well, there's a couple of different ways that we could do this. So for our, for our first example, let's just assume that",
        "start_time": 865.55,
        "end_time": 948.86
    },
    {
        "chunk_id": "chunk_13",
        "text": "be careful with stuff like that. Okay. So that's how we would update a single row of data, but how would we update multiple rows of data? Well, there's a couple of different ways that we could do this. So for our, for our first example, let's just assume that we wanna change all of the email addresses so that they are lowercase. So this might be something that you wanna do to make the, email addresses easier to search. So to do this, we could just assign that column to the lowercase value of itself. So first, let me grab those lowercase values, and to do this we could just say, df and then we could access that email column, and then that's gonna return a series. And then we can just use this dot str class on the series, and use the lower method on that string class. So if I run this, then we can see what this returns is a lowercase version of all these emails. If I look up here in the original data frame, then these have mixed casing in there, and now these are all lowercase. Now this just returns the lowercase values of these emails. It didn't actually make that change. Now in order to make that change, we can simply assign that column to this value. So what I could do here is I could just say, d f email is equal to d f email dot string dot lowercase. So if I run this, and then we look at our data frame, now those changes actually did go through and all of our emails are now lowercase. So that's one way that we can change multiple rows at once, but maybe we want to do something a little more advanced.",
        "start_time": 948.62,
        "end_time": 1035.865
    },
    {
        "chunk_id": "chunk_14",
        "text": "if I run this, and then we look at our data frame, now those changes actually did go through and all of our emails are now lowercase. So that's one way that we can change multiple rows at once, but maybe we want to do something a little more advanced. So there are several ways that we can do this, and we'll go over all 4 popular methods, in order to do this. And a lot of people get these 4 methods confused, so let's go over each one individually and try to explain them in detail. And there's definitely a good reason, why people get these confused, because they're very similar in what they do. So the 4 methods that I'm gonna be talking about are apply, and map, and apply map, and replace. Oops. Let me spell that correctly. Replace. So first, let's take a look at apply. So apply is used for calling a function on our values, and apply can work on either a data frame or a series object, and the behavior might be a little different than you expect for each of those different objects. So first, let's look at how apply works for a series. So when we use this on a series, it can apply a function to every value in our series. So for example, let's say that I wanna see the length of all of our email addresses. Maybe we have a website, and we wanna make sure that none of the email addresses are too long or something like that. So I I can apply the len, the length function, to each value in our series by doing something like this. I can say df and access that email column, and then I can say dot apply lin. So",
        "start_time": 1035.365,
        "end_time": 1121.8551
    },
    {
        "chunk_id": "chunk_15",
        "text": "of the email addresses are too long or something like that. So I I can apply the len, the length function, to each value in our series by doing something like this. I can say df and access that email column, and then I can say dot apply lin. So we'll apply that lin function. And when I run that, what we can see what it's doing here is it's saying, okay, the lin of the first row email addresses was 23, So I've never actually counted up the characters in my email address, but it's telling me it's 23. And then this one says it's 17, and then then it says this one is 17. So that's a quick little way that we can use apply to grab some information about our data, but we can also use this to update values as well. So in this example, I'm just going to create a simple function that returns the upper case version of our email, but the function can be as complicated as you want it to be. So let me write a simple function here, that does what I want it to do. So I'm gonna say, let's see. I'll call this function update email, and this will take in an email value here. And then I'll just return that email in uppercase. So email dot upper. So let me run this. Now again, this is a super basic example here. If I really wanted to uppercase the email addresses, then I would just do the same thing that we did before when we made them lowercase. But I just I'm using this as an example here. So when we apply functions, it's usually to do some more advanced updates, than what we're doing here. But let's apply",
        "start_time": 1121.6951,
        "end_time": 1199.7899
    },
    {
        "chunk_id": "chunk_16",
        "text": "email addresses, then I would just do the same thing that we did before when we made them lowercase. But I just I'm using this as an example here. So when we apply functions, it's usually to do some more advanced updates, than what we're doing here. But let's apply this function to our email column. So to do this, we could say, df and access that email column dot apply, and then we can pass in that update email function that we just wrote. Now we don't want to execute this function, so you don't wanna put parenthesis here. You just wanna pass in, the function without parenthesis so that we're passing in the function itself and not an executed version of itself. Okay. So let me run this cell, and we can see that now we're getting back a series here of our email addresses in, uppercase. Now if, this doesn't actually change our values or change our rows like we saw before. So to do this, we can just assign that to our column. So I can just take what we wrote here, and then I can just set that series equal to, that series with that applied function. So if I run that and then we look at our data frame, then we can see that now our email addresses are all upper case. Now again, this was a pretty simple function here. All we did was return this email dot upper. Now for simple for simple functions like this, you might see people use Lambda functions as well. Now if you're not familiar with Lambda functions, basically they are anonymous functions with a specific name or without a specific name that we can use for things like this. So here's what it would look like",
        "start_time": 1199.47,
        "end_time": 1286.73
    },
    {
        "chunk_id": "chunk_17",
        "text": "simple functions like this, you might see people use Lambda functions as well. Now if you're not familiar with Lambda functions, basically they are anonymous functions with a specific name or without a specific name that we can use for things like this. So here's what it would look like in this example. So let's say that I wanted to convert these back to lowercase. So what I could do is I will just grab this here. Now I'm gonna use a pass in a Lambda function here to dot apply instead of passing in, that other function that we wrote. So I'll say Lambda. And the if you're not familiar with Lambda functions, then the syntax can be a little weird here. But basically, we just have a no name function here and then what we want to return. So I wanna return, x dot lower of that argument that we get passed in. So if I run that and then look at our data frame again, then now we can see that we have the lower case version of our email. So if you're more comfortable writing regular functions, then you can do it this way. But if you are comfortable writing Lambda functions and your function isn't too complicated, then you can always do it this way like we did here. Now we're working with strings here, but you can also use this with numbers where we can run any type of calculations that we want as well. Okay. So this is how apply works on series objects. So now let's look at how apply works with data frames. So far, we've only been using this, with a series. So anytime we access a column like this, that returns a series. And again, when we ran apply",
        "start_time": 1286.41,
        "end_time": 1365.945
    },
    {
        "chunk_id": "chunk_18",
        "text": "well. Okay. So this is how apply works on series objects. So now let's look at how apply works with data frames. So far, we've only been using this, with a series. So anytime we access a column like this, that returns a series. And again, when we ran apply on the series, it ran a function on all of the values in that series. Now, when we run apply on a data frame, it runs a function on each row or column of that data frame. So let's see what this looks like and it should make more sense. So let me grab the example above where we ran the lin, function right here. And let me copy this and paste this down here, and then we'll take a look at what this looks like on a data frame. So again, what this gave us was the length of each value in that email series. So you might think that you can run this same apply method on the entire data frame, and it will give us the length of each value in the data frame, but that's not what it does. So let's see what that gives us. So instead of accessing a specific column, let's just say df dot apply and pass in that lin function. So if I run this, then we get this response that you might not expect. So what's going on here is that it's not applying the length function to every value in the data frame. It's actually applying the length function to each series in the data frame, specifically the columns. So basically what this is telling us is that our first name column has a length of 3. So if we look up here at first, we can see that",
        "start_time": 1365.445,
        "end_time": 1447.5651
    },
    {
        "chunk_id": "chunk_19",
        "text": "in the data frame. It's actually applying the length function to each series in the data frame, specifically the columns. So basically what this is telling us is that our first name column has a length of 3. So if we look up here at first, we can see that first has 3 values. It's telling us that last has 3 values and email has 3 values. So that's just the number of rows in each column, and we can get that same result for a specific series if we manually check the length of one of these. So if I was to say, lin, and access one of these columns, and ran this, then we can see that gives us 3. So that's basically what apply is doing here on the data frame, but it's doing it for every column. And you can also have this apply to rows as well if you change the axis. So we can change the axis here and say, no, I wanna do this on the rows. Whoops. And I put row. I meant to put rows. So if I run this oh, and I made another mistake here. Actually, didn't need to put rows. Rows is the default. I meant to put columns. So if I put columns, then we can see that now, we get 3 as well. But now what it's doing here is it's counting it this way. So it's saying, okay, 1 or row 0, has 3 values, but it's saying, okay, those values are Corey, Shaffer, and then the email. It's not counting it downward. So basically, we wanna use functions that will make sense, to be used on a Series object when using a ply on an entire DataFrame. So for example, let's say that we",
        "start_time": 1447.4851,
        "end_time": 1525.895
    },
    {
        "chunk_id": "chunk_20",
        "text": "but it's saying, okay, those values are Corey, Shaffer, and then the email. It's not counting it downward. So basically, we wanna use functions that will make sense, to be used on a Series object when using a ply on an entire DataFrame. So for example, let's say that we wanted to grab the minimum value from each column. Well, series objects have a min method, so we could pass that into apply and see the minimum value for each series. Now, in our sample data frame, we have all string values. So if we grab the minimum value from a series of strings, then it'll just return the 1, the first one in alphabetical order. So let's see what this would look like. So we can come down here and we can say df dot apply, and now let me pass in that series min method. So I could say pd is what we imported pandas as, pd.series.min. So if I run this, then we can see, okay, it's saying that the, one that comes first in the alphabet in the first category is Corey. The one that comes first in the last names is Doe, so that is, you know, that's a d. These two are s's. That makes sense. And then my email comes before these other two emails. Now it probably would have been better to take a look at this using a series of, numerical data instead, because with numerical data, this stuff, you know, obviously makes more sense. So if we used, series dot min on numerical data, then that would obviously give us the minimum values for each of those numbers. And we can use Lambda functions with this as well, but you just have to remember that the Lambda will be working",
        "start_time": 1525.735,
        "end_time": 1609.8601
    },
    {
        "chunk_id": "chunk_21",
        "text": "obviously makes more sense. So if we used, series dot min on numerical data, then that would obviously give us the minimum values for each of those numbers. And we can use Lambda functions with this as well, but you just have to remember that the Lambda will be working on a series object. So if I come down here, I can say df dot apply, and now let's pass in a Lambda. Now this x here this x is going to be a series, it's not going to be a value. So what methods do a series have? Well, a series has a min method. So let's return the minimum value and run that, and we can see that, that gives us the same response that this one up here gave us. Now, like I said, this is kind of a contrived example because we could get these same results by using the data frames min method, but I just wanted to point out how this actually works. So this is way more useful when your data frame contains numerical data. So for example, we could use NumPy to apply the square root for all of our series objects, or any type of numerical analysis like that. Okay. So running apply on a series, applies a function to every value in the series, and running apply to a data frame like we did here applies a function to every series in the data frame. But you might be wondering if there is a way that we can apply a function to every individual element in the data frame, and that's what apply map is used for. And apply map only works on data frames. Series objects don't have the apply map method. So let me show you how this",
        "start_time": 1609.38,
        "end_time": 1696.36
    },
    {
        "chunk_id": "chunk_22",
        "text": "if there is a way that we can apply a function to every individual element in the data frame, and that's what apply map is used for. And apply map only works on data frames. Series objects don't have the apply map method. So let me show you how this is different. So again, let's use that same built in length function and pass that into apply map. So I'll say df dot apply map, and now let's pass in that built in length function. So if I run this, then we can see that what this does is that it's now applying that length function to each individual value in our data frame. So the first name had these many characters, so first name mine was Corey, so c o r e y, that's 5 characters, and then Jane, and then John, so those are 4 characters. And we saw the length of the emails before, 23/17/17. So that's what this is doing here. It's applying that function to every individual element of our data frame. So this might be, how some of you expected the apply method to work on a data frame, but instead, we use apply map for this. Now, I know that this can be a bit confusing, but hopefully after seeing those differences, it makes a little bit more sense of when we would want to use which. So for example, since we have an entire data frame full of strings in this example, if I wanted all of them to be lowercase, then I could just do something like this. I could say, df dot apply map, and then I can just pass in the string dot lower method. So if I run this, then we can see that now all of the",
        "start_time": 1696.0399,
        "end_time": 1778.59
    },
    {
        "chunk_id": "chunk_23",
        "text": "if I wanted all of them to be lowercase, then I could just do something like this. I could say, df dot apply map, and then I can just pass in the string dot lower method. So if I run this, then we can see that now all of the values in that data frame are lower case. Now if you had numerical data in your data frame, then you would get an error here since you can't run string methods on numbers, so you'd need to pass in a more complicated function that handles that appropriately. Okay. So now we've looked at apply and apply map, and hopefully those make more sense to you now. So now let's look at the map method. Now, the map method only works on a series. So map is used for substituting each value in a series with another value. So for example, let's say that we wanted to, substitute a couple of our first names. So to do this, I could say, df and access that First Name column, which is also a series, and then I can use the map method on this, And now I'm gonna pass in a dictionary of the values that we want to substitute. So let's say instead of Corey, I wanna pass in, Chris, and instead of Jane, I wanted to pass in a value of Mary. So if I run this, then we can see that that returns a series where those first names were substituted out. So Corey was the first value here, now it's Chris. Jane is now Mary. Now one thing that I do wanna point out here is that the values that we didn't substitute were converted to n a n values, not a number values. Now that may or",
        "start_time": 1778.43,
        "end_time": 1864.9199
    },
    {
        "chunk_id": "chunk_24",
        "text": "were substituted out. So Corey was the first value here, now it's Chris. Jane is now Mary. Now one thing that I do wanna point out here is that the values that we didn't substitute were converted to n a n values, not a number values. Now that may or may not be what we want, and I'll show an example of this when we look at, some real world Stack Overflow examples. Now in this example, we likely wouldn't wanna get rid of these other names. So you might be thinking, okay. Well, what if I wanted to keep John, but just substitute these other names? So if that's the case, then instead of using map, we can instead use the replace method. So instead of doing what we did here, I'll just copy this, paste this in here, instead of using map, I can use replace. And if I run this, then now we can see that it's basically the exact same result here, except now we actually have, it didn't replace John with an NAN value. And again, everything that we've done here doesn't actually, change the data frame. If we wanted to set this to the actual column, then we would have to do something like this. We could say that that df first column is equal to that replaced version of the data frame. So if I run this, and then I look at our entire data frame, then now we can see that those values were substituted. Okay. So now that we have looked at a lot of different ways of updating information in our rows and columns, Now let's go over to our larger dataset and look at some real world examples of how we can apply what we have learned here. So",
        "start_time": 1864.76,
        "end_time": 1945.365
    },
    {
        "chunk_id": "chunk_25",
        "text": "values were substituted. Okay. So now that we have looked at a lot of different ways of updating information in our rows and columns, Now let's go over to our larger dataset and look at some real world examples of how we can apply what we have learned here. So let me go over to my Stack Overflow survey data here. So we have our Stack Overflow survey notebook open here, that we've been using throughout this series. And again, if you would like to download these notebooks or the Stack Overflow data in order to follow along, then the links for all of this are in the description section below. Okay. So let's apply some of what we learned here to this dataset. So in the last video where we covered filtering, we looked at filtering salaries over a certain amount, and the column name for salary, it is over here somewhere. It is this one here, converted comp. Now, I'm assuming that's short for converted compensation, and that is converted to United States dollars. So let's say that we wanted to rename that column to where it was a bit more clear. So instead, I'm going to rename this column to Salary USD instead of Converted Comp. So if we remember from earlier in the video, we can do this with the rename method. So if I come down here, then I can say df dot rename, and then we can just pass in the columns that we want to rename. So I'll pass in a dictionary here, but this is only going to have one value. So we want to change converted comp, and we want to set that to I'll call this salary USD. So if I run this, then let me go over here and",
        "start_time": 1945.125,
        "end_time": 2030.675
    },
    {
        "chunk_id": "chunk_26",
        "text": "want to rename. So I'll pass in a dictionary here, but this is only going to have one value. So we want to change converted comp, and we want to set that to I'll call this salary USD. So if I run this, then let me go over here and see if this looks good. Okay. So that looks good. That changed. Now after you make sure that it made the change that you wanted it to make and that it's not a mistake, then we can actually apply that to our data frame by setting in place is equal to true. Now that's why in place equal to true is actually a good idea, because sometimes, you know, when you're working in pandas, we're always doing these different types of renames and filters and things like that, and sometimes we're gonna do things wrong. So it's always better to check and make sure that it made the change that you meant to make first, and then apply that change to your data frame to actually make the solidify those changes. So now, let's see if we have access to that salary USD column. And if I look at that, then we can see that we do have a salary USD column in this data frame, so that change did work. Okay. So what is something else that we can do here, to see what we have already learned? Okay. So here's an example here. So we've looked at this hobbyist column a few times in this series. This is a column where people answered on the survey whether they code as a hobby in their free time. And let's look at this column real quick. We can kinda see it here. It has a bunch of yes yes, no",
        "start_time": 2030.515,
        "end_time": 2115.48
    },
    {
        "chunk_id": "chunk_27",
        "text": "hobbyist column a few times in this series. This is a column where people answered on the survey whether they code as a hobby in their free time. And let's look at this column real quick. We can kinda see it here. It has a bunch of yes yes, no values. Let me actually print this out down here. So I will access that hobbyist column, and we can see that this is a bunch of yes no values here. So let's say that we wanted to convert these values and map all of the yes responses to a true boolean value and the no's to false. So how would we do this? Well, one way that we could do this is with the map method that we just learned about. So what we could do is we could say dphobbyist.map, and then pass in a dictionary here of the substitutions that we want to make. So for the yes values, I will convert this to a boolean of true, and for the no values, I will convert this to a boolean of false. So if I run this, then if we compare the results that we got up here and the results that we're getting down here, we can see that all the yeses are mapped to true and all the noes are mapped to false. Now I don't believe there is actually an in place argument, for map, so what we can do here is we can just set that series and set that equal to the mapped version of that series. So now if I run this and look at our data frame, now we can see that that entire column is now true false values instead of yes no values. Now remember, when we use map,",
        "start_time": 2115.16,
        "end_time": 2205.245
    },
    {
        "chunk_id": "chunk_28",
        "text": "set that series and set that equal to the mapped version of that series. So now if I run this and look at our data frame, now we can see that that entire column is now true false values instead of yes no values. Now remember, when we use map, then anything that isn't in, our dictionary here, so anything outside of a yes or no answer, would be converted to an NAN value. I think there are other columns in this survey where there are yes, no, and not sure answers or something like that. So if we only wanted to replace the yes or no values and leave the others untouched, then instead, we could use the, replace method instead. But map works for this example because I know that this column only has yes and no. Okay. So that is a quick review of some of what we learned in this video. I'm not going to go over everything again since this video is already getting a little long, but I did want to show you some examples of how updating values, works when and how this can be applied to real world data like this survey. Okay. So before we end here, I would like to mention that we do have a sponsor for this video, and that sponsor is brilliant.org. So So in this series, we've been learning about Pandas and how to analyze data in Python. And Brilliant would be an excellent way to supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze",
        "start_time": 2204.745,
        "end_time": 2287.975
    },
    {
        "chunk_id": "chunk_29",
        "text": "supplement what you learn here with their hands on courses. They have some excellent courses and lessons that do a deep dive on how to think about and analyze data correctly. For data analysis fundamentals, I would really recommend checking out their statistics course, which shows you how to analyze graphs and determine significance in the data. And I would also recommend their machine learning course, which takes data analysis to a new level where you'll learn about the techniques being used that allow machines to make decisions where there's just too many variables for a human to consider. So to support my channel and learn more about Brilliant, you can go to brilliant.orgforward/cms to sign up for free. And also, the first 200 people that go to that link will get 20% off the annual premium subscription, and you can find that link in the description section below. Again, that's brilliant.orgforward/cms. Okay. So I think that's gonna do it for this Pandas video. I hope you feel like you got a good idea for how we can update the information within our rows and columns. We started off a bit simple, making changes in specific spots, and then going a little more advanced when we learned about apply, map, and apply map. Now I know that those can be confusing to some people, but hopefully you feel like you got, an understanding of how each of those work. Now originally, I was also going to show how to add and remove rows and columns in this video, but this is getting a bit long, so I'm just going to save that for our next video. So in the next video, we'll learn how to add and remove rows and columns from our data frame, and that should be a",
        "start_time": 2287.575,
        "end_time": 2363.32
    },
    {
        "chunk_id": "chunk_30",
        "text": "and remove rows and columns in this video, but this is getting a bit long, so I'm just going to save that for our next video. So in the next video, we'll learn how to add and remove rows and columns from our data frame, and that should be a much shorter video. But if anyone has any questions about what will be covered in this video, then feel free to ask in the comments section below, and I'll do my best to answer those. If you enjoy these tutorials and would like to support them, then there are several ways you can do that. The easiest way is to simply like the video and give it a thumbs up, and it's always a huge help to share these videos with anyone who you think would find them useful. And if you have the means, you can contribute through Patreon, and there's a link to that page in the description section below. Be sure to subscribe for future videos, and thank you all for watching.",
        "start_time": 2363.1602,
        "end_time": 2390.2751
    }
]